use std::fmt::{Debug, Display, Formatter};

use regex::Regex;

#[derive(Debug)]
pub(crate) struct Options<'a> {
    content: &'a str,
    skip_commands: Option<&'a Regex>,
}

impl<'a> Options<'a> {
    pub(crate) fn new(content: &'a str) -> Self {
        Options {
            content,
            skip_commands: None,
        }
    }

    pub(crate) fn with_skip_commands(mut self, skip_commands: Option<&'a Regex>) -> Self {
        self.skip_commands = skip_commands;
        self
    }

    pub(crate) fn build(&'a self) -> CommandsBlocks<'a> {
        CommandsBlocks::parse(self).expect("Failed to parse the MARKDOWN file")
    }
}

#[derive(Debug, PartialEq, Eq)]
struct ParserError {
    message: String,
}

impl ParserError {
    fn new(message: String) -> Self {
        ParserError { message }
    }

    fn err<R>(message: String) -> Result<R, ParserError> {
        Err(Self::new(message))
    }
}

impl Display for ParserError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

impl std::error::Error for ParserError {}

#[derive(Debug, PartialEq, Eq)]
pub(crate) struct CommandBlock<'a> {
    lines: Vec<&'a str>,
}

impl<'a> Display for CommandBlock<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let mut lines = self.lines.iter();

        if let Some(first_line) = lines.next() {
            write!(f, "{}", first_line)?;

            for line in lines {
                write!(f, "\n{}", line)?;
            }
        }

        Ok(())
    }
}

#[derive(Debug, PartialEq, Eq)]
pub(crate) struct CommandsBlocks<'a> {
    /* TODO: Consider switching to a VecDeque given that we pop elements from the front when iterating. */
    commands: Vec<CommandBlock<'a>>,
}

impl<'a> CommandsBlocks<'a> {
    fn parse(options: &'a Options<'a>) -> Result<Self, ParserError> {
        let mut commands = vec![];
        let mut buffered_commands = vec![];

        let mut within_command_block = None;
        let mut skip_command_block = false;

        for line in options.content.lines() {
            if let Some(offset) = line.find("```shell") {
                if within_command_block.is_some() {
                    return ParserError::err("Nested code block are not supported".to_string());
                }

                within_command_block = Some(offset);
                continue;
            }

            if let Some(offset) = within_command_block {
                if line.len() > offset && line[offset..].eq("```") {
                    if !skip_command_block {
                        commands.push(CommandBlock {
                            lines: buffered_commands,
                        });
                        buffered_commands = vec![];
                    }

                    within_command_block = None;
                    skip_command_block = false;
                    continue;
                }
            }

            if skip_command_block {
                continue;
            }

            if let Some(offset) = within_command_block {
                let mut command_line = if line.len() > offset {
                    &line[offset..]
                } else {
                    ""
                };

                /* TODO: Should we support this? */
                if command_line.starts_with("$ ") {
                    command_line = &command_line[2..];
                }

                buffered_commands.push(command_line);

                /* Check if the command needs to be skipped and clear the buffer if so */
                if let Some(regex) = &options.skip_commands {
                    if regex.is_match(&buffered_commands.join(" ")) {
                        skip_command_block = true;
                        buffered_commands.clear();
                        continue;
                    }
                }
            }
        }

        if !buffered_commands.is_empty() {
            ParserError::err("Failed to find closing code block".to_string())
        } else {
            Ok(CommandsBlocks { commands })
        }
    }

    pub(crate) fn as_shell_script(&self) -> String {
        let mut buffer_command = String::new();
        buffer_command.push_str(
            r#"#!/bin/sh

# Generated by the MARKDOWN executor
# This file is automatically deleted once the execution completes

set -e

"#,
        );

        for command in &self.commands {
            buffer_command.push_str("echo '---'\n");

            let mut lines = command
                .lines
                .iter()
                .map(|line| str::replace(line, "\\", "\\\\"))
                .map(|line| str::replace(line.as_str(), "'", "'\\''"));
            if let Some(first_line) = lines.next() {
                if first_line.contains('$') {
                    buffer_command.push_str("# shellcheck disable=SC2016\n");
                }
                if first_line.ends_with("\\\\") {
                    let without_backslash = &first_line[0..first_line.len() - 2];
                    buffer_command.push_str(format!("echo '$ {without_backslash}'\\\\\n").as_str());
                } else {
                    buffer_command.push_str(format!("echo '$ {first_line}'\n").as_str());
                }

                for line in lines {
                    if line.ends_with("\\\\") {
                        let without_backslash = &line[0..line.len() - 2];
                        buffer_command
                            .push_str(format!("echo '> {without_backslash}'\\\\\n").as_str());
                    } else {
                        buffer_command.push_str(format!("echo '> {line}'\n").as_str());
                    }
                }
            }

            buffer_command.push_str(format!("{command}\n\n").as_str());
        }

        buffer_command
    }
}

impl Display for CommandsBlocks<'_> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        for command in &self.commands {
            writeln!(f, "{}", command)?;
        }
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod parser {
        use super::*;

        #[test]
        fn parse_empty_content() {
            let content = "";
            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = ok_empty();
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_without_commands() {
            let content = r#"# README

No commands here!!
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = ok_empty();
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_one_single_line_command() {
            let content = r#"# README

Before command

```shell
$ ls -la
```

After command
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = ok_of_strs(vec!["ls -la"]);
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_multiple_single_line_command() {
            let content = r#"# README

```shell
$ echo "Hello"
```

```shell
$ ls -la
```

```shell
$ echo "Goodbye"
```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = Ok(CommandsBlocks {
                commands: vec![
                    CommandBlock {
                        lines: vec!["echo \"Hello\""],
                    },
                    CommandBlock {
                        lines: vec!["ls -la"],
                    },
                    CommandBlock {
                        lines: vec!["echo \"Goodbye\""],
                    },
                ],
            });
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_different_indentation() {
            let content = r#"# README

```shell
$ echo "Hello"
```

- `ls` command

  ```shell
  $ ls -la
  ```

  1. `echo` command

     ```shell
     $ echo "Goodbye"
     ```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = Ok(CommandsBlocks {
                commands: vec![
                    CommandBlock {
                        lines: vec!["echo \"Hello\""],
                    },
                    CommandBlock {
                        lines: vec!["ls -la"],
                    },
                    CommandBlock {
                        lines: vec!["echo \"Goodbye\""],
                    },
                ],
            });
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_one_multi_line_command_backslash() {
            let content = r#"# README

```shell
$ java \
  -jar target/app.jar
```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = Ok(CommandsBlocks {
                commands: vec![CommandBlock {
                    lines: vec!["java \\", "  -jar target/app.jar"],
                }],
            });
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_one_multi_line_command_here_document_without_indentation() {
            let content = r#"# README

```shell
$ patch -p1 -u './Test.java' << EOF
--- ./Test.java
+++ ./Test.java
@@ -1,3 +1,2 @@
 package demo;

 -import java.io.Console;
EOF
```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = Ok(CommandsBlocks {
                commands: vec![CommandBlock {
                    lines: vec![
                        "patch -p1 -u './Test.java' << EOF",
                        "--- ./Test.java",
                        "+++ ./Test.java",
                        "@@ -1,3 +1,2 @@",
                        " package demo;",
                        "",
                        " -import java.io.Console;",
                        "EOF",
                    ],
                }],
            });
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_one_multi_line_command_here_document_with_indentation() {
            let content = r#"# README

- Step 1

  ```shell
  $ patch -p1 -u './Test.java' << EOF
  --- ./Test.java
  +++ ./Test.java
  @@ -1,3 +1,2 @@
   package demo;

   -import java.io.Console;
  EOF
  ```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = Ok(CommandsBlocks {
                commands: vec![CommandBlock {
                    lines: vec![
                        "patch -p1 -u './Test.java' << EOF",
                        "--- ./Test.java",
                        "+++ ./Test.java",
                        "@@ -1,3 +1,2 @@",
                        " package demo;",
                        "",
                        " -import java.io.Console;",
                        "EOF",
                    ],
                }],
            });
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_one_multi_line_command_block() {
            let content = r#"# README

```shell
while [ "$(curl --silent --output /dev/null --write-out '%{http_code}' 'http://localhost:8080')" -ne '200' ]
do
  echo 'Waiting for the application to start'
  sleep 1
done
```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = Ok(CommandsBlocks {
                commands: vec![CommandBlock {
                    lines: vec![
                        "while [ \"$(curl --silent --output /dev/null --write-out '%{http_code}' 'http://localhost:8080')\" -ne '200' ]",
                        "do",
                        "  echo 'Waiting for the application to start'",
                        "  sleep 1",
                        "done",
                    ],
                }],
            });
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_multiple_single_line_commands() {
            let content = r#"# README

```shell
$ echo "Line 1"
$ echo "Line 2"
$ echo "Line 3"
```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = ok_of_strs(vec![
                "echo \"Line 1\"",
                "echo \"Line 2\"",
                "echo \"Line 3\"",
            ]);
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_with_multiple_multi_line_commands() {
            let content = r#"# README

```shell
$ echo "Before"
$ java \
  -jar target/app-1.jar
$ java \
  -jar target/app-2.jar
$ echo "After"
```
"#;

            let options = Options::new(content);
            let parsed = CommandsBlocks::parse(&options);
            let expected = ok_of_strs(vec![
                "echo \"Before\"",
                "java \\",
                "  -jar target/app-1.jar",
                "java \\",
                "  -jar target/app-2.jar",
                "echo \"After\"",
            ]);
            assert_eq!(expected, parsed);
        }

        #[test]
        fn parse_content_skip_commands() {
            let content = r#"# README

```shell
$ echo "Line 1"
```

```shell
$ echo "Hello there"
```

```shell
$ echo "Line 2"
$ echo "Hello there"
```
"#;

            let skip_commands = Regex::new(r"Line \d").expect("Invalid skip commands regex");
            let options = Options::new(content).with_skip_commands(Some(&skip_commands));
            let parsed = CommandsBlocks::parse(&options);
            let expected = ok_of_strs(vec!["echo \"Hello there\""]);
            assert_eq!(expected, parsed);
        }
    }

    mod formatter {
        use super::*;

        #[test]
        fn format_empty_command() {
            let commands = empty();
            let formatted = format!("{}", commands);
            let expected = "";
            assert_eq!(expected, formatted);
        }

        #[test]
        fn format_one_single_line_command() {
            let commands = of_strs(vec!["ls -la"]);
            let formatted = format!("{}", commands);
            let expected = r#"ls -la
"#;
            assert_eq!(expected, formatted);
        }

        #[test]
        fn format_multiple_single_line_command() {
            let commands = of_strs(vec!["echo \"Hello\"", "ls -la", "echo \"Goodbye\""]);
            let formatted = format!("{}", commands);
            let expected = r#"echo "Hello"
ls -la
echo "Goodbye"
"#;
            assert_eq!(expected, formatted);
        }

        #[test]
        fn format_one_multi_line_command() {
            let commands = CommandsBlocks {
                commands: vec![CommandBlock {
                    lines: vec!["java \\", " -jar target/app.jar"],
                }],
            };
            let formatted = format!("{}", commands);
            let expected = r#"java \
 -jar target/app.jar
"#;
            assert_eq!(expected, formatted);
        }

        #[test]
        fn format_multiple_single_line_commands() {
            let commands = of_strs(vec![
                "echo \"Line 1\"",
                "echo \"Line 2\"",
                "echo \"Line 3\"",
            ]);
            let formatted = format!("{}", commands);
            let expected = r#"echo "Line 1"
echo "Line 2"
echo "Line 3"
"#;
            assert_eq!(expected, formatted);
        }

        #[test]
        fn format_multiple_multi_line_commands() {
            let commands = CommandsBlocks {
                commands: vec![
                    CommandBlock {
                        lines: vec!["echo \"Before\""],
                    },
                    CommandBlock {
                        lines: vec!["java \\", " -jar target/app-1.jar"],
                    },
                    CommandBlock {
                        lines: vec!["java \\", " -jar target/app-2.jar"],
                    },
                    CommandBlock {
                        lines: vec!["echo \"After\""],
                    },
                ],
            };
            let formatted = format!("{}", commands);
            let expected = r#"echo "Before"
java \
 -jar target/app-1.jar
java \
 -jar target/app-2.jar
echo "After"
"#;
            assert_eq!(expected, formatted);
        }

        #[test]
        fn format_as_shell_script_with_default_execution() {
            let commands = CommandsBlocks {
                commands: vec![CommandBlock {
                    lines: vec!["java \\", " -XshowSettings:vm \\", " --version"],
                }],
            };
            let formatted = commands.as_shell_script();
            let expected = r#"#!/bin/sh

# Generated by the MARKDOWN executor
# This file is automatically deleted once the execution completes

set -e

echo '---'
echo '$ java '\\
echo '>  -XshowSettings:vm '\\
echo '>  --version'
java \
 -XshowSettings:vm \
 --version

"#;
            assert_eq!(expected, formatted);
        }
    }

    fn ok_empty() -> Result<CommandsBlocks<'static>, ParserError> {
        Ok(empty())
    }

    fn ok_of_strs(commands: Vec<&str>) -> Result<CommandsBlocks<'_>, ParserError> {
        Ok(of_strs(commands))
    }

    fn empty() -> CommandsBlocks<'static> {
        CommandsBlocks { commands: vec![] }
    }

    fn of_strs(commands: Vec<&str>) -> CommandsBlocks<'_> {
        CommandsBlocks {
            commands: vec![CommandBlock { lines: commands }],
        }
    }
}
